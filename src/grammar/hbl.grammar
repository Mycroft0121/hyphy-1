#include "wchar.h"
#include "parser2013.h"

COMPILER hyphy_batch_language
  
/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/
CHARACTERS
/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/

  LETTER        = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  DIGIT         = "0123456789".
  DOT           = '.'.
  UNDERSCORE    = '_'.
  CR            = '\r'.
  LF            = '\n'.
  TAB           = '\t'.
  NOT_DQUOTE    = ANY - '"'.
  NOT_SQUOTE    = ANY - '\''.
  NOT_FIRST_CHAR = LETTER + DIGIT + UNDERSCORE. 

 
/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/
TOKENS
/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/

  IDENTIFIER  = (LETTER|UNDERSCORE) {NOT_FIRST_CHAR} {DOT NOT_FIRST_CHAR {NOT_FIRST_CHAR}} .
  FLOAT       = ((DIGIT {DIGIT} [DOT {DIGIT}]) | (DOT {DIGIT})) [('e'|'E') ['+'|'-'] DIGIT {DIGIT}] .
  SINGLE_QUOTE_STRING      = '\'' {NOT_SQUOTE | "\\\'" } '\'' .
  DOUBLE_QUOTE_STRING      = '"' {NOT_DQUOTE | "\\\"" } '"' .
  NONE_OBJECT              = "None".
  OPEN_PARENTHESIS         = '('.
  CLOSE_PARENTHESIS        = ')'.
  EQUAL                    = '='.
  ASSIGN                   = ":=".
  COMMA                    = ','.
  CLOSE_BRACE              = '}'.
  OPEN_BRACE               = '{'.
  CLOSE_BRACKET            = ']'.
  OPEN_BRACKET             = '['.
  MULTIPLY                 = '*'.
  COLON                    = ':'.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO CR LF

IGNORE CR + LF + TAB
 
/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/
PRODUCTIONS
/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/


/*------------------------------------------------------------------------*/
ident <_Formula& f, _FormulaParsingContext& fpc>
= IDENTIFIER  (. _parser2013_pushIdentifier (this, f, fpc, t->val, false, false); .)
.

/*------------------------------------------------------------------------*/
number <_Formula& f, _FormulaParsingContext& fpc>
= FLOAT  (. _parser2013_pushNumber (this, f, fpc, t->val); .)
.

/*------------------------------------------------------------------------*/

matrix_row  <_SimpleList & matrix_entries, _FormulaParsingContext& fpc, unsigned long& column_count, bool& is_const>
= OPEN_BRACE  (. _Formula* f = new _Formula; unsigned long my_column_count = 0; .)
    (
        IF (_parser2013_isFollowedByAnCommaOrClosingBrace (this)) MULTIPLY 
        | expression <*f, fpc>  
    ) (. _parser2013_add_matrix_entry (this, matrix_entries, f, fpc, is_const); my_column_count++; .)
    {    
        COMMA (. f = new _Formula; .)
        (
        IF (_parser2013_isFollowedByAnCommaOrClosingBrace (this)) MULTIPLY 
        | expression <*f, fpc>  
        ) (. _parser2013_add_matrix_entry (this, matrix_entries, f, fpc, is_const); my_column_count++; .)
    } 
  CLOSE_BRACE (. _parser2013_matrix_checkRowLengths (this, fpc, column_count, my_column_count); .)
.

dense_matrix <_Formula& f, _FormulaParsingContext& fpc>
= OPEN_BRACE (. _SimpleList matrix_entries; unsigned long n_rows = 0; unsigned long n_cols = 0; bool is_const = true; .)
    matrix_row  <matrix_entries, fpc, n_cols, is_const> (. n_rows ++; .)
    {matrix_row <matrix_entries, fpc, n_cols, is_const> (. n_rows ++; .) }  
  CLOSE_BRACE (. _parser2013_pushObject (this, f, fpc, _parser2013_createDenseMatrix (this, fpc, &matrix_entries, n_rows, n_cols, is_const));  .)
.

/*------------------------------------------------------------------------*/

matrix_element  <_SimpleList & matrix_definition, _FormulaParsingContext& fpc, bool& is_const> 
= OPEN_BRACE (. _Formula * h = new _Formula, * v = new _Formula, * d = new _Formula; .)
        expression <*h, fpc> 
        COMMA 
        expression <*v, fpc> 
        COMMA
        expression <*d, fpc> 
   CLOSE_BRACE (. _parser2013_pushSparseElementEntry (this, fpc, matrix_definition, h, v, d, is_const); .)
.
   
sparse_matrix <_Formula& f, _FormulaParsingContext& fpc>
= OPEN_BRACE  (. bool is_matrix = false; _SimpleList* matrix_definition = new _SimpleList; 
        _Formula * hd = new _Formula, *vd = new _Formula; bool is_const = true; .)
    (
        IF (_parser2013_StringAndColon (this)) (
            [ (. _Formula *key = new _Formula, *value = new _Formula; .)
                expression <*key, fpc> COLON  expression <*value, fpc> 
                (. _parser2013_addADictionaryElement (this, *matrix_definition, key, value, fpc, is_const); .)
            ]
            {
                (. _Formula *key = new _Formula, *value = new _Formula; .)
                COMMA expression <*key, fpc> COLON  expression <*value, fpc> 
                (. _parser2013_addADictionaryElement (this, *matrix_definition, key, value, fpc, is_const); .)            
            }
        )
        |
        ( (. is_matrix = true; .)
            expression <*hd, fpc> 
            [ COMMA expression <*vd, fpc> 
            {COMMA matrix_element <*matrix_definition, fpc, is_const>}
            ]
        ) 
    )  
  CLOSE_BRACE 
    (.  if (is_matrix) {
            _parser2013_createSparseMatrix (this, f, fpc, hd, vd, matrix_definition, is_const);}
        else {
            _parser2013_createDictionary (this, f, fpc, *matrix_definition, is_const);
            delete (hd); delete (vd);
        }
    .)
.

/*------------------------------------------------------------------------*/

function_call <_Formula& f, _FormulaParsingContext& fpc>
= (. _List argument_names; .)
  IDENTIFIER (. _String func_id (t->val); .)
  OPEN_PARENTHESIS
  {expression <f, fpc> (. argument_names.AppendNewInstance(new _String);.)
  { ',' expression <f, fpc> (. argument_names.AppendNewInstance(new _String);.) } 
  }
  CLOSE_PARENTHESIS
  (. _parser2013_pushFunctionCall (this, f, fpc, func_id, argument_names); .)
  .
  

/*------------------------------------------------------------------------*/

primitive  <_Formula& f, _FormulaParsingContext& fpc>
= number <f, fpc>
| DOUBLE_QUOTE_STRING (. _parser2013_pushString (this, f, fpc, t->val); .)
| SINGLE_QUOTE_STRING (. _parser2013_pushString (this, f, fpc, t->val); .)
| OPEN_PARENTHESIS expression <f, fpc> CLOSE_PARENTHESIS 
| IF (_parser2013_TwoOpenBraces (this)) dense_matrix <f, fpc>
| sparse_matrix <f, fpc>
| NONE_OBJECT (. _parser2013_pushNone (this, f, fpc); .)
| IF (_parser2013_IdentFollowedByAnOpenParenthesis(this)) function_call <f, fpc> 
| ident <f, fpc> 
//| primitive <f, fpc> '[' expression <f,fpc> ']'
.

/*------------------------------------------------------------------------*/

lvalue <_Formula& f, _FormulaParsingContext& fpc>
= indexing_operation <f, fpc> 
.

/*------------------------------------------------------------------------*/


indexing_operation <_Formula& f, _FormulaParsingContext& fpc> 
= primitive <f, fpc> 
  [
  OPEN_BRACKET expression <f, fpc> CLOSE_BRACKET
  [
    OPEN_BRACKET expression <f, fpc> CLOSE_BRACKET
  ]
  ]
.

  
/*------------------------------------------------------------------------*/

reference_like <_Formula& f, _FormulaParsingContext& fpc>
= (. long op_code = HY_OP_CODE_NONE; .)
  [ 
    MULTIPLY  (. op_code = HY_OP_CODE_MUL; .)
  | "^"  (. op_code = HY_OP_CODE_POWER; .)
  ]
  indexing_operation <f, fpc> 
  (. if (op_code != HY_OP_CODE_NONE) _parser2013_pushOp (this, f,fpc,op_code,1); .) 
  .
  
/*------------------------------------------------------------------------*/

power_like <_Formula& f, _FormulaParsingContext& fpc>
= reference_like <f, fpc> (. long op_code; .)
  {
  "^"  (. op_code = HY_OP_CODE_POWER; .)
  reference_like <f, fpc> 
  (. _parser2013_pushOp (this, f, fpc, op_code , 2); .) 
  }
  .
  
/*------------------------------------------------------------------------*/

multiplication_like <_Formula& f, _FormulaParsingContext& fpc>
= power_like <f, fpc> (. long op_code; .)
  {
  (
  MULTIPLY  (. op_code = HY_OP_CODE_MUL; .)
  | "/" (. op_code = HY_OP_CODE_DIV; .)
  | "$" (. op_code = HY_OP_CODE_IDIV; .)
  | "%" (. op_code = HY_OP_CODE_MOD; .)
  )
  power_like <f, fpc> 
  (. _parser2013_pushOp (this, f, fpc, op_code , 2); .) 
  }
  .
  
/*------------------------------------------------------------------------*/

addition_like <_Formula& f, _FormulaParsingContext& fpc>
= (. long unary_code = HY_OP_CODE_NONE, op_code; .)
  [ 
    (
    "+"  (. unary_code = HY_OP_CODE_ADD; .)
    | "-" (. unary_code = HY_OP_CODE_SUB; .)
    )
  ]
  multiplication_like <f, fpc> (. 
    if (unary_code != HY_OP_CODE_NONE) {
     _parser2013_pushOp (this, f, fpc, unary_code , 1); 
    } .)
  {
  (
  "+"  (. op_code = HY_OP_CODE_ADD; .)
  | "-" (. op_code = HY_OP_CODE_SUB; .)
  )
  multiplication_like <f, fpc> 
  (. _parser2013_pushOp (this, f, fpc, op_code , 2); .) 
  }
  .
  
/*------------------------------------------------------------------------*/

logical_comp <_Formula& f, _FormulaParsingContext& fpc>
= addition_like <f, fpc> (. long op_code; .)
  {
  (
  "=="  (. op_code = HY_OP_CODE_EQ; .)
  | "!=" (. op_code = HY_OP_CODE_NEQ; .)
  | ">"  (. op_code = HY_OP_CODE_GREATER; .)
  | "<"  (. op_code = HY_OP_CODE_LESS; .)
  | ">=" (. op_code = HY_OP_CODE_GEQ; .)
  | "<=" (. op_code = HY_OP_CODE_LEQ; .)
  )
  addition_like <f, fpc> 
  (. _parser2013_pushOp (this, f, fpc, op_code , 2); .) 
  }
  .
  
/*------------------------------------------------------------------------*/

logical_and <_Formula& f, _FormulaParsingContext& fpc>
= logical_comp <f, fpc>
  {
  "&&" logical_comp <f, fpc> 
  (. _parser2013_pushOp (this, f, fpc, HY_OP_CODE_AND , 2); .) 
  }
  .

/*------------------------------------------------------------------------*/

logical_or <_Formula& f, _FormulaParsingContext& fpc>
= logical_and <f, fpc>
  {
  "||" logical_and <f, fpc> 
  (. _parser2013_pushOp (this, f, fpc, HY_OP_CODE_OR , 2); .) 
  }
  .
/*------------------------------------------------------------------------*/

expression <_Formula& f, _FormulaParsingContext& fpc>
=
SYNC logical_or <f, fpc>  
.

/*------------------------------------------------------------------------*/
statement <_ExecutionList &current_code_stream>
=   IF (_parser2013_isSimpleStatement (this))
      (. _Formula f; _FormulaParsingContext fpc; .)
      expression <f, fpc> ';'  
        (. _String s ((_String*)f.Compute()->toStr()); printf ("Formula: %s\n", s.sData); .)
        
|       (. _Formula f, f2; _FormulaParsingContext fpc;.) 
lvalue <f2, fpc> (
    EQUAL  
    | ASSIGN
) expression <f, fpc> ';' 
        (. printf ("\nvalue assignment"); .)
/*
| lvalue ':=' expression ';' (. printf ("\nformula assignment"); .)
*/
.

/*------------------------------------------------------------------------*/
block <_ExecutionList &current_code_stream>
= 
'{'
{statement <current_code_stream>| block <current_code_stream>}
'}'
.

/*------------------------------------------------------------------------*/

hyphy_batch_language 
= (. _ExecutionList current_code_stream; .)
{statement <current_code_stream> | block <current_code_stream>} 
| (. _Formula f; _FormulaParsingContext fpc; .)
expression <f, fpc> SYNC /* a single expression for calculator-style parsing */
.

END hyphy_batch_language.
