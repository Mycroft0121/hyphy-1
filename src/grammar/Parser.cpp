/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/


#include <wchar.h>
#include "Parser.h"
#include "Scanner.h"




void Parser::SynErr(int n) {
	if (errDist >= minErrDist) errors->SynErr(la->line, la->col, n);
	errDist = 0;
}

void Parser::SemErr(const wchar_t* msg) {
	if (errDist >= minErrDist) errors->Error(t->line, t->col, msg);
	errDist = 0;
}

void Parser::Get() {
	for (;;) {
		t = la;
		la = scanner->Scan();
		if (la->kind <= maxT) { ++errDist; break; }

		if (dummyToken != t) {
			dummyToken->kind = t->kind;
			dummyToken->pos = t->pos;
			dummyToken->col = t->col;
			dummyToken->line = t->line;
			dummyToken->next = NULL;
			coco_string_delete(dummyToken->val);
			dummyToken->val = coco_string_create(t->val);
			t = dummyToken;
		}
		la = t;
	}
}

void Parser::Expect(int n) {
	if (la->kind==n) Get(); else { SynErr(n); }
}

void Parser::ExpectWeak(int n, int follow) {
	if (la->kind == n) Get();
	else {
		SynErr(n);
		while (!StartOf(follow)) Get();
	}
}

bool Parser::WeakSeparator(int n, int syFol, int repFol) {
	if (la->kind == n) {Get(); return true;}
	else if (StartOf(repFol)) {return false;}
	else {
		SynErr(n);
		while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0))) {
			Get();
		}
		return StartOf(syFol);
	}
}

void Parser::ident(_Formula& f, _FormulaParsingContext& fpc) {
		Expect(_IDENTIFIER);
		_parser2013_pushIdentifier (this, f, fpc, t->val, false, false); 
}

void Parser::number(_Formula& f, _FormulaParsingContext& fpc) {
		Expect(_FLOAT);
		_parser2013_pushNumber (this, f, fpc, t->val); 
}

void Parser::matrix_row() {
		Expect(10 /* "{" */);
		_Formula f; _FormulaParsingContext fpc; 
		expression(f, fpc);
		while (la->kind == 11 /* "," */) {
			Get();
			expression(f, fpc);
		}
		Expect(12 /* "}" */);
}

void Parser::expression(_Formula& f, _FormulaParsingContext& fpc) {
		while (!(StartOf(1))) {SynErr(30); Get();}
		logical_or(f, fpc);
}

void Parser::dense_matrix() {
		Expect(10 /* "{" */);
		printf ("\nStart matrix declaration"); 
		matrix_row();
		while (la->kind == 10 /* "{" */) {
			matrix_row();
		}
		Expect(12 /* "}" */);
		printf ("\nEnd matrix declaration"); 
}

void Parser::function_call(_Formula& f, _FormulaParsingContext& fpc) {
		_List argument_names; 
		Expect(_IDENTIFIER);
		_String func_id (t->val); 
		Expect(_OPEN_PARENTHESIS);
		while (StartOf(2)) {
			expression(f, fpc);
			argument_names.AppendNewInstance(new _String);
			while (la->kind == 11 /* "," */) {
				Get();
				expression(f, fpc);
				argument_names.AppendNewInstance(new _String);
			}
		}
		Expect(_CLOSE_PARENTHESIS);
		_parser2013_pushFunctionCall (this, f, fpc, func_id, argument_names); 
}

void Parser::primitive(_Formula& f, _FormulaParsingContext& fpc) {
		if (la->kind == _FLOAT) {
			number(f, fpc);
		} else if (la->kind == _DOUBLE_QUOTE_STRING) {
			Get();
			_parser2013_pushString (this, f, fpc, t->val); 
		} else if (la->kind == _SINGLE_QUOTE_STRING) {
			Get();
			_parser2013_pushString (this, f, fpc, t->val); 
		} else if (la->kind == _OPEN_PARENTHESIS) {
			Get();
			expression(f, fpc);
			Expect(_CLOSE_PARENTHESIS);
		} else if (la->kind == 10 /* "{" */) {
			dense_matrix();
		} else if (la->kind == _NONE_OBJECT) {
			Get();
			_parser2013_pushNone (this, f, fpc); 
		} else if (_parser2013_isFollowedByAnOpenParenthesis(this)) {
			function_call(f, fpc);
		} else if (la->kind == _IDENTIFIER) {
			ident(f, fpc);
		} else SynErr(31);
}

void Parser::lvalue(_Formula& f, _FormulaParsingContext& fpc) {
		ident(f, fpc);
}

void Parser::reference_like(_Formula& f, _FormulaParsingContext& fpc) {
		long op_code = HY_OP_CODE_NONE; 
		if (la->kind == 13 /* "*" */ || la->kind == 14 /* "^" */) {
			if (la->kind == 13 /* "*" */) {
				Get();
				op_code = HY_OP_CODE_MUL; 
			} else {
				Get();
				op_code = HY_OP_CODE_POWER; 
			}
		}
		primitive(f, fpc);
		if (op_code != HY_OP_CODE_NONE) _parser2013_pushOp (this, f,fpc,op_code,1); 
}

void Parser::power_like(_Formula& f, _FormulaParsingContext& fpc) {
		reference_like(f, fpc);
		long op_code; 
		while (la->kind == 14 /* "^" */) {
			Get();
			op_code = HY_OP_CODE_POWER; 
			reference_like(f, fpc);
			_parser2013_pushOp (this, f, fpc, op_code , 2); 
		}
}

void Parser::multiplication_like(_Formula& f, _FormulaParsingContext& fpc) {
		power_like(f, fpc);
		long op_code; 
		while (StartOf(3)) {
			if (la->kind == 13 /* "*" */) {
				Get();
				op_code = HY_OP_CODE_MUL; 
			} else if (la->kind == 15 /* "/" */) {
				Get();
				op_code = HY_OP_CODE_DIV; 
			} else if (la->kind == 16 /* "$" */) {
				Get();
				op_code = HY_OP_CODE_IDIV; 
			} else {
				Get();
				op_code = HY_OP_CODE_MOD; 
			}
			power_like(f, fpc);
			_parser2013_pushOp (this, f, fpc, op_code , 2); 
		}
}

void Parser::addition_like(_Formula& f, _FormulaParsingContext& fpc) {
		multiplication_like(f, fpc);
		long op_code; 
		while (la->kind == 18 /* "+" */ || la->kind == 19 /* "-" */) {
			if (la->kind == 18 /* "+" */) {
				Get();
				op_code = HY_OP_CODE_ADD; 
			} else {
				Get();
				op_code = HY_OP_CODE_SUB; 
			}
			multiplication_like(f, fpc);
			_parser2013_pushOp (this, f, fpc, op_code , 2); 
		}
}

void Parser::logical_comp(_Formula& f, _FormulaParsingContext& fpc) {
		addition_like(f, fpc);
		long op_code; 
		while (StartOf(4)) {
			switch (la->kind) {
			case 20 /* "==" */: {
				Get();
				op_code = HY_OP_CODE_EQ; 
				break;
			}
			case 21 /* "!=" */: {
				Get();
				op_code = HY_OP_CODE_NEQ; 
				break;
			}
			case 22 /* ">" */: {
				Get();
				op_code = HY_OP_CODE_GREATER; 
				break;
			}
			case 23 /* "<" */: {
				Get();
				op_code = HY_OP_CODE_LESS; 
				break;
			}
			case 24 /* ">=" */: {
				Get();
				op_code = HY_OP_CODE_GEQ; 
				break;
			}
			case 25 /* "<=" */: {
				Get();
				op_code = HY_OP_CODE_LEQ; 
				break;
			}
			}
			addition_like(f, fpc);
			_parser2013_pushOp (this, f, fpc, op_code , 2); 
		}
}

void Parser::logical_and(_Formula& f, _FormulaParsingContext& fpc) {
		logical_comp(f, fpc);
		while (la->kind == 26 /* "&&" */) {
			Get();
			logical_comp(f, fpc);
			_parser2013_pushOp (this, f, fpc, HY_OP_CODE_AND , 2); 
		}
}

void Parser::logical_or(_Formula& f, _FormulaParsingContext& fpc) {
		logical_and(f, fpc);
		while (la->kind == 27 /* "||" */) {
			Get();
			logical_and(f, fpc);
			_parser2013_pushOp (this, f, fpc, HY_OP_CODE_OR , 2); 
		}
}

void Parser::statement(_ExecutionList &current_code_stream) {
		if (_parser2013_isSimpleStatement (this)) {
			_Formula f; _FormulaParsingContext fpc; 
			expression(f, fpc);
			Expect(28 /* ";" */);
			_String s ((_String*)f.Compute()->toStr()); printf ("Formula: %s\n", s.sData); 
		} else if (la->kind == _IDENTIFIER) {
			_Formula f, f2; _FormulaParsingContext fpc;
			lvalue(f2, fpc);
			if (la->kind == _EQUAL) {
				Get();
			} else if (la->kind == _ASSIGN) {
				Get();
			} else SynErr(32);
			expression(f, fpc);
			Expect(28 /* ";" */);
			printf ("\nvalue assignment"); 
		} else SynErr(33);
}

void Parser::block(_ExecutionList &current_code_stream) {
		Expect(10 /* "{" */);
		while (StartOf(2)) {
			if (StartOf(2)) {
				statement(current_code_stream);
			} else {
				block(current_code_stream);
			}
		}
		Expect(12 /* "}" */);
}

void Parser::hyphy_batch_language() {
		if (StartOf(1)) {
			_ExecutionList current_code_stream; 
			while (StartOf(2)) {
				if (StartOf(2)) {
					statement(current_code_stream);
				} else {
					block(current_code_stream);
				}
			}
		} else if (StartOf(2)) {
			_Formula f; _FormulaParsingContext fpc; 
			expression(f, fpc);
			while (!(la->kind == _EOF)) {SynErr(34); Get();}
		} else SynErr(35);
}




// If the user declared a method Init and a mehtod Destroy they should
// be called in the contructur and the destructor respctively.
//
// The following templates are used to recognize if the user declared
// the methods Init and Destroy.

template<typename T>
struct ParserInitExistsRecognizer {
	template<typename U, void (U::*)() = &U::Init>
	struct ExistsIfInitIsDefinedMarker{};

	struct InitIsMissingType {
		char dummy1;
	};
	
	struct InitExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static InitIsMissingType is_here(...);

	// exist only if ExistsIfInitIsDefinedMarker is defined
	template<typename U>
	static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U>*);

	enum { InitExists = (sizeof(is_here<T>(NULL)) == sizeof(InitExistsType)) };
};

template<typename T>
struct ParserDestroyExistsRecognizer {
	template<typename U, void (U::*)() = &U::Destroy>
	struct ExistsIfDestroyIsDefinedMarker{};

	struct DestroyIsMissingType {
		char dummy1;
	};
	
	struct DestroyExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static DestroyIsMissingType is_here(...);

	// exist only if ExistsIfDestroyIsDefinedMarker is defined
	template<typename U>
	static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U>*);

	enum { DestroyExists = (sizeof(is_here<T>(NULL)) == sizeof(DestroyExistsType)) };
};

// The folloing templates are used to call the Init and Destroy methods if they exist.

// Generic case of the ParserInitCaller, gets used if the Init method is missing
template<typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
struct ParserInitCaller {
	static void CallInit(T *t) {
		// nothing to do
	}
};

// True case of the ParserInitCaller, gets used if the Init method exists
template<typename T>
struct ParserInitCaller<T, true> {
	static void CallInit(T *t) {
		t->Init();
	}
};

// Generic case of the ParserDestroyCaller, gets used if the Destroy method is missing
template<typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
struct ParserDestroyCaller {
	static void CallDestroy(T *t) {
		// nothing to do
	}
};

// True case of the ParserDestroyCaller, gets used if the Destroy method exists
template<typename T>
struct ParserDestroyCaller<T, true> {
	static void CallDestroy(T *t) {
		t->Destroy();
	}
};

void Parser::Parse() {
	t = NULL;
	la = dummyToken = new Token();
	la->val = coco_string_create(L"Dummy Token");
	Get();
	hyphy_batch_language();
	Expect(0);
}

Parser::Parser(Scanner *scanner) {
	maxT = 29;

	ParserInitCaller<Parser>::CallInit(this);
	dummyToken = NULL;
	t = la = NULL;
	minErrDist = 2;
	errDist = minErrDist;
	this->scanner = scanner;
	errors = new Errors();
}

bool Parser::StartOf(int s) {
	const bool T = true;
	const bool x = false;

	static bool set[5][31] = {
		{T,T,T,T, T,T,T,x, x,x,T,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{T,T,T,T, T,T,T,x, x,x,T,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,T,T,T, T,T,T,x, x,x,T,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, T,T,x,x, x,x,x}
	};



	return set[s][la->kind];
}

Parser::~Parser() {
	ParserDestroyCaller<Parser>::CallDestroy(this);
	delete errors;
	delete dummyToken;
}

Errors::Errors() {
	count = 0;
}

void Errors::SynErr(int line, int col, int n) {
	wchar_t* s;
	switch (n) {
			case 0: s = coco_string_create(L"EOF expected"); break;
			case 1: s = coco_string_create(L"IDENTIFIER expected"); break;
			case 2: s = coco_string_create(L"FLOAT expected"); break;
			case 3: s = coco_string_create(L"SINGLE_QUOTE_STRING expected"); break;
			case 4: s = coco_string_create(L"DOUBLE_QUOTE_STRING expected"); break;
			case 5: s = coco_string_create(L"NONE_OBJECT expected"); break;
			case 6: s = coco_string_create(L"OPEN_PARENTHESIS expected"); break;
			case 7: s = coco_string_create(L"CLOSE_PARENTHESIS expected"); break;
			case 8: s = coco_string_create(L"EQUAL expected"); break;
			case 9: s = coco_string_create(L"ASSIGN expected"); break;
			case 10: s = coco_string_create(L"\"{\" expected"); break;
			case 11: s = coco_string_create(L"\",\" expected"); break;
			case 12: s = coco_string_create(L"\"}\" expected"); break;
			case 13: s = coco_string_create(L"\"*\" expected"); break;
			case 14: s = coco_string_create(L"\"^\" expected"); break;
			case 15: s = coco_string_create(L"\"/\" expected"); break;
			case 16: s = coco_string_create(L"\"$\" expected"); break;
			case 17: s = coco_string_create(L"\"%\" expected"); break;
			case 18: s = coco_string_create(L"\"+\" expected"); break;
			case 19: s = coco_string_create(L"\"-\" expected"); break;
			case 20: s = coco_string_create(L"\"==\" expected"); break;
			case 21: s = coco_string_create(L"\"!=\" expected"); break;
			case 22: s = coco_string_create(L"\">\" expected"); break;
			case 23: s = coco_string_create(L"\"<\" expected"); break;
			case 24: s = coco_string_create(L"\">=\" expected"); break;
			case 25: s = coco_string_create(L"\"<=\" expected"); break;
			case 26: s = coco_string_create(L"\"&&\" expected"); break;
			case 27: s = coco_string_create(L"\"||\" expected"); break;
			case 28: s = coco_string_create(L"\";\" expected"); break;
			case 29: s = coco_string_create(L"??? expected"); break;
			case 30: s = coco_string_create(L"this symbol not expected in expression"); break;
			case 31: s = coco_string_create(L"invalid primitive"); break;
			case 32: s = coco_string_create(L"invalid statement"); break;
			case 33: s = coco_string_create(L"invalid statement"); break;
			case 34: s = coco_string_create(L"this symbol not expected in hyphy_batch_language"); break;
			case 35: s = coco_string_create(L"invalid hyphy_batch_language"); break;

		default:
		{
			wchar_t format[20];
			coco_swprintf(format, 20, L"error %d", n);
			s = coco_string_create(format);
		}
		break;
	}
	wprintf(L"-- line %d col %d: %ls\n", line, col, s);
	coco_string_delete(s);
	count++;
}

void Errors::Error(int line, int col, const wchar_t *s) {
	wprintf(L"-- line %d col %d: %ls\n", line, col, s);
	count++;
}

void Errors::Warning(int line, int col, const wchar_t *s) {
	wprintf(L"-- line %d col %d: %ls\n", line, col, s);
}

void Errors::Warning(const wchar_t *s) {
	wprintf(L"%ls\n", s);
}

void Errors::Exception(const wchar_t* s) {
	wprintf(L"%ls", s); 
	exit(1);
}


